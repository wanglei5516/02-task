一、输出结果

10

a数组里存放的都是 function(){console.log(i)} 函数调用的时候，在作用域内寻找i值，此时i为10



二、输出结果

undefined

有 let 块级作用域，此时 tmp 还没被赋值



三、输出结果

Math.min(...arr)



四、三者区别

var 是 ES5 用法，此时只有函数作用域和全局作用域，存在变量提升

let 和 const 是 ES6用法，在块级作用域内，不存在变量提升，也不可重复声明

let 是变量，const 是常量，这里常量指的是地址不能变化



五、输出结果

20

箭头函数的 this 在定义时确定，此时和 fn 函数的 this 指向相同

fn 在调用时确定 this 指向，Obj.fn() 则表示 fn 函数的 this 指向 obj , obj.a = 20



六、Symbol 用途

生成唯一的值，用做对象属性名，防止命名冲突

此外还是私有成员，外部无法访问



七、浅拷贝 与 深拷贝

浅拷贝对 对象 的每个属性，如果是基本类型就拷贝值；如果是引用类型就拷贝地址，原对象和拷贝对象更改值会一起变化。

深拷贝是全部都拷贝值，原对象和拷贝对象更改互不打扰



八、TS 和 JS 关系

TS 是 JS 的超集，可以在 TS 中使用 JS 语法，TS 是强类型，JS 是弱类型



九、TS 优缺点

优点：

类型检查，编写时会提示语法错误，及早发现错误

提高代码可读性

返回值有自动的类型推论

缺点：

any 类型



十、引用计数

原理：

当有指针指向这块内存时，计数器加1；当指向此内存的指针销毁或指向其他内存时，计数器减1。当引用计数为0时，表示此块内存被释放。

优点：

快，及时回收垃圾对象

减少程序卡顿时间

缺点：

无法释放 循环引用的内存

资源消耗大



十一、标记整理算法流程

先进行标记，把有标记的活动对象进行整理，然后再清除，

这样清除完对象的空闲空间就是连续的，减少碎片化空间，进行空间优化



十二、V8 新生代存储区垃圾回收的流程

新生代内存区分为两个等大空间，使用空间为 From ，空闲空间为 To ，对象放在 From 空间，标记整理后将有标记的活动对象拷贝至 To 空间



十三、增量标记算法何时使用 和 工作原理

在 V8 引擎的老生代对象垃圾回收里 使用

将垃圾回收拆分成一个个小部分，替代之前一口气做完的垃圾回收，由于垃圾回收是阻塞程序执行的，所以避免了“长”时间的等待，提升用户体验。

垃圾回收和程序进行交替执行，每次只标记一层可达对象。